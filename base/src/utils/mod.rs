use std::future::Future;
use std::str::FromStr;

use bitcoin::secp256k1::PublicKey;
use bitcoin::{Address, Network, ScriptBuf};
use candid::utils::{ArgumentDecoder, ArgumentEncoder};
use candid::Principal;
use ic_cdk::api::call::{call_with_payment, CallResult};
use ic_cdk::api::management_canister::bitcoin::{
    BitcoinNetwork, GetBalanceRequest, GetCurrentFeePercentilesRequest, GetUtxosRequest,
    GetUtxosResponse, MillisatoshiPerByte, Satoshi, SendTransactionRequest, Utxo,
};

use crate::constants::{
    DEFAULT_FEE_MILLI_SATOSHI, GET_CURRENT_FEE_PERCENTILES_CYCLES, GET_UTXOS_COST_CYCLES,
    SEND_TRANSACTION_BASE_CYCLES, SEND_TRANSACTION_PER_BYTE_CYCLES,
};
use crate::domain::Wallet;
use crate::tx::TransactionInfo;
use crate::{bitcoins, ecdsa, ICBitcoinNetwork};
use crate::{constants::GET_BALANCE_COST_CYCLES, error::Error};

pub type BaseResult<T> = Result<T, Error>;

/// Returns the balance of the given bitcoin address from IC management canister
///
/// NOTE: Relies on the `bitcoin_get_balance` endpoint.
/// See https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_get_balance
pub async fn balance(
    address: impl Into<String>,
    network: BitcoinNetwork,
) -> Result<Satoshi, Error> {
    let args = (GetBalanceRequest {
        address: address.into(),
        network,
        min_confirmations: None,
    },);

    let fee = GET_BALANCE_COST_CYCLES;

    call_management_with_payment("bitcoin_get_balance", args, fee)
        .await
        .map(|(balance,)| balance)
        .map_err(|e| e.into())
}

/// Build an unsigned transaction for the given amount, network, address
pub async fn build_unsigned_transaction(
    wallet: Wallet,
    amount: Satoshi,
    receive_address: String,
    network: ICBitcoinNetwork,
) -> BaseResult<TransactionInfo> {
    let fee_percentiles = bitcoins::get_current_fee_percentiles(network).await?;

    let fee_per_byte = if fee_percentiles.is_empty() {
        DEFAULT_FEE_MILLI_SATOSHI
    } else {
        // Choose the median of the percentiles
        fee_percentiles[fee_percentiles.len() / 2]
    };

    ic_cdk::print("Fetching UTXOs... \n");

    // Get the all UTXOS for the given address and network
    let utxos = bitcoins::get_utxos(wallet.address.to_string(), network)
        .await?
        .utxos;

    let receive_address = Address::from_str(&receive_address)
        .map_err(|e| Error::BitcoinAddressError(e.to_string()))
        .and_then(|address| {
            address
                .require_network(match_network(network))
                .map_err(|e| e.into())
        })?;

    // Build transaction
    build_transaction(wallet, &utxos, &receive_address, amount, fee_per_byte).await
}

async fn build_transaction(
    wallet: Wallet,
    utxos: &[Utxo],
    receive_address: &Address,
    amount: Satoshi,
    fee_per_byte: MillisatoshiPerByte,
) -> BaseResult<TransactionInfo> {
    todo!()
}
/// Sends a transaction to bitcoin network
///
/// NOTE: Relies on the `bitcoin_send_transaction` endpoint.
/// See https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_send_transaction
pub async fn send_transaction(transaction: Vec<u8>, network: BitcoinNetwork) -> BaseResult<()> {
    let fee = SEND_TRANSACTION_BASE_CYCLES
        + (transaction.len() as u64) * SEND_TRANSACTION_PER_BYTE_CYCLES;

    let args = (SendTransactionRequest {
        transaction,
        network,
    },);

    call_management_with_payment("bitcoin_send_transaction", args, fee)
        .await
        .map(|((),)| ())
        .map_err(|e| e.into())
}

/// Create wallet for a given Principal, pk1, pk2 and bitcoin network
///
pub async fn create_wallet(
    principal: Principal,
    steward_canister: Principal,
    bitcoin_network: ICBitcoinNetwork,
    key_name: String,
) -> BaseResult<Wallet> {
    if !is_normal_principal(principal) {
        return Err(Error::InvalidPrincipal(principal));
    }

    // Create a new wallet for this principal.
    // Right now there is only one wallet for each principal,
    // so the it is derived from the principal itself.
    let derivation_path = vec![principal.as_slice().to_vec()];

    // First public key is from the Wallet canister(this canister).
    let pk1 = ecdsa::public_key(key_name, derivation_path.clone(), None).await?;

    // Second public key is generated by the Steward canister.
    let pk2: Result<(Vec<u8>,), Error> = ic_cdk::call(
        steward_canister,
        "public_key",
        (bitcoin_network, derivation_path.clone()),
    )
    .await
    .map_err(|e| e.into());

    let pk2 = pk2?.0;

    let witness_script = bitcoin::blockdata::script::Builder::new()
        .push_int(2)
        .push_slice(PublicKey::from_slice(&pk1)?.serialize())
        .push_slice(PublicKey::from_slice(&pk2)?.serialize())
        .push_int(2)
        .push_opcode(bitcoin::blockdata::opcodes::all::OP_CHECKMULTISIG)
        .into_script();

    let script_pub_key = ScriptBuf::new_p2wsh(&witness_script.wscript_hash());

    // Generate the wallet address from the P2WSH script pubkey
    let address = bitcoin::Address::from_script(&script_pub_key, match_network(bitcoin_network))
        .map_err(Error::from)?;

    Ok(Wallet {
        witness_script,
        derivation_path,
        address,
    })
}

pub fn is_normal_principal(principal: Principal) -> bool {
    principal != Principal::management_canister() && Principal::anonymous() != principal
}

pub fn call_management_with_payment<T: ArgumentEncoder, R: for<'a> ArgumentDecoder<'a>>(
    method: &str,
    args: T,
    fee: u64,
) -> impl Future<Output = CallResult<R>> + Send + Sync {
    call_with_payment(Principal::management_canister(), method, args, fee)
}

pub fn validate_network(network: &str) -> ICBitcoinNetwork {
    if network == "mainnet" {
        ICBitcoinNetwork::Mainnet
    } else if network == "testnet" {
        ICBitcoinNetwork::Testnet
    } else {
        ICBitcoinNetwork::Regtest
    }
}

// Utility function to translate the bitcoin network from the IC cdk
// to the bitoin network of the rust-bitcoin library.
fn match_network(bitcoin_network: BitcoinNetwork) -> Network {
    match bitcoin_network {
        BitcoinNetwork::Mainnet => Network::Bitcoin,
        BitcoinNetwork::Testnet => Network::Testnet,
        BitcoinNetwork::Regtest => Network::Regtest,
    }
}
